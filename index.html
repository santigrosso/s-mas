<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>S-MAS • Sprint Mechanics Assessment (v3.9.4)</title>
<style>
  :root{
    --bg:#0b1b2b; --fg:#ffffff; --acc:#ff7a00; --mut:#b8c3cf; --panel:#11263b; --ok:#19b36a; --bad:#e74c3c; --bdr:#204667;
    --tab-active:#0f2a44; --tab-inactive:#c9d1dc; --tab-inactive-text:#0f1720;
    --scrub-bg:#1a324c; --scrub-buffer:#2b5178; --scrub-played:#ff7a00; --scrub-thumb:#ffffff;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid #163551;display:flex;gap:12px;align-items:center}
  header h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.2px}
  header .pill{background:var(--panel);padding:6px 10px;border-radius:8px;font-size:12px}
  main{display:grid;grid-template-columns:1fr;gap:10px;padding:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .card{background:var(--panel);border:1px solid #163551;border-radius:12px;padding:10px}
  #videoWrap{position:relative;width:100%;aspect-ratio:16/9;background:#000;border-radius:12px;overflow:hidden}
  video{width:100%;height:100%;display:block;object-fit:contain;background:#000}
  canvas{position:absolute;left:0;top:0}
  #magnifier{position:absolute; left:0; top:0; pointer-events:none; display:none;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--acc);color:#000;border:none;border-radius:10px;padding:10px 12px;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;color:var(--fg);border:1px solid #335b87}
  button.small{padding:6px 8px;border-radius:8px;font-weight:600}
  .label{font-size:12px;color:var(--mut)}
  .hr{height:1px;background:#173a5d;margin:10px 0}
  .pill{background:var(--panel);padding:6px 10px;border-radius:8px;font-size:12px}
  .tabsWrap{width:100%;}
  .tabs{display:flex;gap:0;width:100%;}
  .tab{
    flex:1 1 0; text-align:center; padding:7px 4px;
    background:var(--tab-inactive); color:var(--tab-inactive-text);
    border:1px solid #b8c4d2; border-right:none; border-bottom:1px solid #b8c4d2;
    cursor:pointer; font-size:12.5px; user-select:none; line-height:1;
    border-top-left-radius:10px; border-top-right-radius:10px;
    border-bottom-left-radius:0; border-bottom-right-radius:0;
    display:flex; align-items:center; justify-content:center; gap:6px;
  }
  .tab:last-child{border-right:1px solid #b8c4d2}
  .tab.active{ background:var(--tab-active); color:#fff; border-color:var(--tab-active); border-bottom-color:transparent; }
  .tab .tick{display:none; font-weight:900}
  .tab.captured .tick{display:inline}
  .momentDesc{
    width:100%; background:var(--tab-active); border:1px solid var(--tab-active); border-top:none;
    margin-top:-1px; padding:6px 10px; color:#d8e4f1;
    border-bottom-left-radius:10px;border-bottom-right-radius:10px;
    font-size:13px; min-height:34px; display:flex; align-items:center; box-sizing:border-box;
  }
  .q{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px;background:#0f2a44;border-radius:10px;border:1px solid var(--bdr); margin-bottom:8px}
  .q label{flex:1}
  .switch{position:relative;width:36px;height:22px;flex:0 0 36px}
  .switch input{opacity:0;width:0;height:0}
  .slider{ position:absolute;cursor:pointer;inset:0;background:#6b7280;border-radius:999px;transition:background .2s ease, box-shadow .2s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.12); }
  .slider:before{ content:""; position:absolute; height:18px; width:18px; left:2px; top:2px; background:white; border-radius:50%; transition:transform .2s ease; box-shadow:0 1px 2px rgba(0,0,0,.35); }
  .switch input:checked + .slider{ background:var(--ok); box-shadow: inset 0 0 0 1px rgba(0,0,0,.12); }
  .switch input:checked + .slider:before{ transform: translateX(14px); }
  button[disabled]{opacity:.5; cursor:not-allowed}
  .help{font-weight:900; border:1px solid var(--bdr); border-radius:50%; width:22px; height:22px; display:inline-flex; align-items:center; justify-content:center; font-size:13px; color:#d0def0; margin-left:6px; cursor:pointer; touch-action:manipulation}
  .helpTip{position:absolute; background:#0b2236; border:1px solid #2a4a6f; padding:8px 10px; border-radius:8px; color:#d8e4f1; font-size:12px; max-width:260px; z-index:1000; box-shadow:0 6px 20px rgba(0,0,0,.35)}
  .scrubWrap{margin:8px 0 6px}
  .scrubRow{display:flex;align-items:center;gap:10px}
  .time{font-variant-numeric:tabular-nums; font-size:12px; color:var(--mut); min-width:60px; text-align:center}
  .scrubber{ position:relative; height:10px; flex:1 1 auto; border-radius:999px; background:var(--scrub-bg); cursor:pointer; touch-action:none; }
  .scrubber .buffer{position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:var(--scrub-buffer);width:0%}
  .scrubber .played{position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:var(--scrub-played);width:0%}
  .scrubber .thumb{ position:absolute; top:50%; transform:translate(-50%,-50%); width:14px; height:14px; border-radius:50%; background:#ffffff; box-shadow:0 1px 2px rgba(0,0,0,.5); }
  footer{padding:16px;text-align:center;color:#9fb1c7;font-size:12px}
  #report{ display:none; }

  /* Nuevo contenedor que envuelve video + scrubber */
  #viewArea{ position:relative; }

  @media print {
    @page { size: A4; margin: 6mm 10mm 8mm 10mm; }
    body { background: #fff; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    header, #app, footer { display: none !important; }
    #report { display: block; background:#fff; color:#000; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #report .page { page-break-after: always; }
    #report h1, #report h2, #report h3 { color:#0b1b2b; }
    #report .legend { font-size:12px; color:#333; }
    #report .momentBlock { break-inside: avoid; page-break-inside: avoid; margin: 5mm 0; padding-bottom: 1.5mm; border-bottom: 1px solid #eee; }
    #report .momentBlock:last-child { border-bottom:none; }
    #report img { width:60%; height:auto; border:1px solid #e5e7eb; border-radius:6px; background:#fff; }
    #report .row { display:flex; gap:8px; align-items:flex-start; }
    #report .col { flex:1; }
    #report .meta { font-size:11px; color:#444; }
    #report ul { margin:2px 0 0 16px; font-size:11px; }
    #report .notes { margin-top:2mm; font-size:11px; color:#222; white-space:pre-wrap; }
    #report .needBox { border:1px solid #a6c8ff; background:#e9f2ff; padding:6px 8px; border-radius:6px; font-size:12px; color:#0b1b2b; }
    #printFooter { position: fixed; bottom: 0; left: 0; right: 0; text-align:center; font-size:10px; color:#4b5563; border-top:1px solid #e5e7eb; padding-top:6px; }
  }
</style>
</head>
<body>
<header>
  <h1>S-MAS • Sprint Mechanics Assessment</h1>
  <span class="pill">Local • Offline</span>
  <span class="pill">HEVC / 240 fps</span>
</header>

<div id="app">
  <main>
    <div class="row">
      <div class="card" style="flex:2 1 520px">
        <div class="controls" style="justify-content:space-between;margin-bottom:8px">
         <div class="controls">
  <input id="file" type="file" accept="video/*" />
  <label class="label" for="athleteName" style="margin-left:8px">Nombre:</label>
  <input id="athleteName" type="text" placeholder="Nombre y apellido" 
         style="width:200px;background:#0f2a44;color:#fff;border:1px solid var(--bdr);border-radius:8px;padding:6px"/>
  <button class="ghost small" id="clearState">Limpiar</button>
</div>
          <div class="controls">
            <span class="label">fps objetivo</span>
            <input id="fps" type="number" value="240" min="1" max="480" style="width:80px;background:#0f2a44;color:#fff;border:1px solid var(--bdr);border-radius:8px;padding:6px"/>
          </div>
        </div>

        <div class="tabsWrap">
          <div class="tabs" id="tabs"></div>
          <div class="momentDesc" id="momentDesc"></div>
        </div>

        <!-- Contenedor general del video + barra -->
        <div id="viewArea">
          <div id="videoWrap">
            <video id="vid" playsinline muted controls preload="metadata"></video>
            <canvas id="overlay"></canvas>
            <canvas id="magnifier" width="1" height="1"></canvas>
          </div>

          <div class="scrubWrap">
            <div class="scrubRow">
              <div class="time" id="curT">0:00</div>
              <div class="scrubber" id="scrubber">
                <div class="buffer" id="bufBar"></div>
                <div class="played" id="playBar"></div>
                <div class="thumb" id="thumb" style="left:0%"></div>
              </div>
              <div class="time" id="durT">0:00</div>
            </div>
          </div>
        </div>

        <div class="controls" style="margin-top:8px;flex-wrap:wrap">
          <button id="play" class="small">▶︎ Play/Pause</button>
          <button id="back1" class="small">−1 frame</button>
          <button id="fwd1" class="small">+1 frame</button>
          <button id="back10" class="small">−10</button>
          <button id="fwd10" class="small">+10</button>
          <button id="fs" class="small" title="Ver en pantalla completa">Zoom</button>
          <span class="pill">t=<span id="ctime">0.000</span>s • frame <b id="fnum">0</b></span>
          <span class="pill">momento: <b id="curMomentLabel">Toe-off</b></span>
        </div>

        <div class="hr"></div>
      </div>

      <div class="card" style="flex:1 1 360px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <strong>Guías</strong>
          <button id="invert" class="ghost small" title="Espejar guías izquierda/derecha">Invertir (izq/der)</button>
        </div>
        <div id="guidesPanel"></div>

        <div class="hr"></div>

        <div class="score" id="scoreCard" style="margin-bottom:6px">
          <span class="pill">Momento: <b id="momentScore">0</b></span>
          <span class="pill">Total: <b id="totalScore">0</b></span>
          <span class="pill">Clasificación: <b id="grade">Excelente (0–1)</b></span>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <strong>Preguntas (on/off)</strong>
          <span class="label">toca para alternar</span>
        </div>
        <div id="questions"></div>

        <div class="hr"></div>
        <div class="grid">
          <label class="label">Notas del momento</label>
          <textarea id="notes" rows="4" style="width:100%;background:#0f2a44;color:#fff;border:1px solid var(--bdr);border-radius:8px;padding:8px"></textarea>
        </div>

        <div class="hr"></div>
        <div class="grid">
          <button id="snap" class="small">Capturar imagen</button>
        </div>

        <div class="grid" style="margin-top:8px">
          <button id="printReport" disabled>Generar reporte (Imprimir → PDF)</button>
          <span class="label" id="reportHint">Necesitás capturar los 5 momentos (ver tildes en las pestañas).</span>
        </div>
      </div>
    </div>
  </main>
</div>

<div id="report">
  <div id="reportContent"></div>
  <div id="printFooter">Desarrollado por Santiago Grosso – S-MAS Project · 2025</div>
</div>

<footer>Desarrollado por Santiago Grosso – S-MAS Project · 2025</footer>

<script>
/* ===== Descripciones ===== */
const DESCRIPTIONS={
  toeoff:"Punto inmediatamente anterior a que el pie contralateral deje el suelo.",
  mvp:"Punto intermedio entre el toe-off y el touch-down; la pelvis se encuentra en su punto más alto de la fase de swing.",
  lateswing:"Punto de máxima extensión de rodilla durante la fase de swing.",
  touchdown:"Punto de primer contacto con el suelo.",
  midstance:"Punto donde la pelvis está posicionada directamente sobre la articulación del tobillo."
};

/* ===== Momentos/Preguntas ===== */
const MOMENTS=[
  {key:'toeoff',label:'Toe-off'},
  {key:'mvp',label:'Max Vertical Projection'},
  {key:'lateswing',label:'Late Swing'},
  {key:'touchdown',label:'Touchdown'},
  {key:'midstance',label:'Mid-stance'},
];
const QUESTIONS={
  toeoff:["¿Demasiada extensión de cadera?"],                               // #1
  mvp:["¿Rotación excesiva de tronco?","¿Está el talón de la pierna trasera por encima de la pantorrilla?"], // #2 #3
  lateswing:["¿Anteversión pélvica o extensión lumbar entre MVP y Late swing?","¿Está la rodilla por detrás de los glúteos?"], // #4 #5
  touchdown:["¿Está el tronco inclinado hacia delante?","¿Hay anteversión pélvica o extensión lumbar?","¿Hay más de 20° entre ambos muslos?","¿Está el pie muy adelantado en relación al CdG?","¿La tibia está inclinada?","¿El primer apoyo es muy marcado con talón o punta?"], // #6..#11
  midstance:["¿Está la rodilla por delante de la punta del pie?"]            // #12
};

/* ===== Estado ===== */
const GRADE=(s)=> s<=1?"Excelente (0–1)": s===2?"Bueno (2)": s<=5?"Promedio (3–5)": s===6?"Pobre (6)": s<=11?"Muy pobre (7–11)":"Extremadamente pobre (12)";
let state={
  fps:240,invert:false,curMoment:'toeoff',
  moments:Object.fromEntries(MOMENTS.map(m=>[m.key,{
    t:0,frame:0,notes:'',checks:QUESTIONS[m.key].map(()=>false), snapshots:[], captured:false, guides: {}
  }]))
};

/* ===== DOM ===== */
const $=s=>document.querySelector(s);
const file=$('#file'),vid=$('#vid'),wrap=$('#videoWrap');
const nameInput = document.getElementById('athleteName');
const cvs=$('#overlay'),ctx=cvs.getContext('2d');
const mag=$('#magnifier'), mctx=mag.getContext('2d');
const fpsInput=$('#fps'),ctime=$('#ctime'),fnum=$('#fnum');
const tabs=$('#tabs'),momentDesc=$('#momentDesc'),questions=$('#questions'),curMomentLabel=$('#curMomentLabel');
const notesEl=$('#notes'), guidesPanel=$('#guidesPanel');
const printBtn=$('#printReport'),reportHint=$('#reportHint');
const invertBtn=$('#invert');
const momentScoreEl=document.getElementById('momentScore'), totalScoreEl=document.getElementById('totalScore'), gradeEl=document.getElementById('grade');
const scrub=$('#scrubber'), playBar=$('#playBar'), bufBar=$('#bufBar'), thumb=$('#thumb'), curT=$('#curT'), durT=$('#durT');

/* ===== Tooltips ===== */
let tipEl=null, tipAnchor=null;
function toggleTip(anchor, text){ if(tipEl && tipAnchor===anchor){ closeTip(); return; } showTip(anchor, text); }
function showTip(anchorEl, text){
  closeTip(); tipEl=document.createElement('div'); tipEl.className='helpTip'; tipEl.textContent=text;
  document.body.appendChild(tipEl); tipAnchor=anchorEl; positionTip();
  setTimeout(()=>{
    document.addEventListener('mousedown', onDocDown, true);
    document.addEventListener('touchstart', onDocDown, {passive:false, capture:true});
    window.addEventListener('keydown', onKey);
    window.addEventListener('scroll', closeTip, {passive:true});
    window.addEventListener('resize', onResize, {passive:true});
  },0);
}
function positionTip(){ if(!tipEl || !tipAnchor) return;
  const r=tipAnchor.getBoundingClientRect(); const tt=tipEl.getBoundingClientRect();
  let left = r.left - tt.width - 8; let top  = r.top + window.scrollY - (tt.height/2) + (r.height/2);
  if(left < 6){ left = r.right + 8; } const maxTop = window.scrollY + window.innerHeight - tt.height - 6; const minTop = window.scrollY + 6;
  top = Math.max(minTop, Math.min(maxTop, top)); tipEl.style.left = left + 'px'; tipEl.style.top  = top + 'px';
}
function onDocDown(e){ if(!tipEl) return; if(tipEl.contains(e.target) || e.target===tipAnchor){ return; } closeTip(); }
function onKey(e){ if(e.key==='Escape') closeTip(); }
function onResize(){ positionTip(); }
function closeTip(){ if(!tipEl) return; tipEl.remove(); tipEl=null; tipAnchor=null;
  document.removeEventListener('mousedown', onDocDown, true);
  document.removeEventListener('touchstart', onDocDown, {capture:true});
  window.removeEventListener('keydown', onKey);
  window.removeEventListener('scroll', closeTip);
  window.removeEventListener('resize', onResize);
}

/* ===== Helpers ===== */
function ensureGuideState(momentKey, guideKey){
  const m=state.moments[momentKey];
  if(!m.guides[guideKey]){ m.guides[guideKey]={on:false, data:{}}; }
  return m.guides[guideKey];
}
function allCaptured(){ return MOMENTS.every(m=>state.moments[m.key].captured); }
function updateReportAvailability(){ const ok=allCaptured(); printBtn.disabled=!ok; reportHint.style.display=ok?'none':'inline'; }
function setMoment(key){
  state.curMoment=key;
  renderTabs(); renderGuidesPanel();
  momentDesc.textContent=DESCRIPTIONS[key];
  curMomentLabel.textContent=MOMENTS.find(m=>m.key===key).label;
  renderQuestions(); notesEl.value=state.moments[key].notes||''; refreshScores(); draw();
}
function renderTabs(){
  tabs.innerHTML='';
  MOMENTS.forEach(m=>{
    const b=document.createElement('button');
    b.className='tab'+(state.curMoment===m.key?' active':'');
    if(state.moments[m.key].captured) b.classList.add('captured');
    b.dataset.key=m.key; b.onclick=()=>setMoment(m.key);
    b.innerHTML=`<span class="text">${m.label}</span><span class="tick">✓</span>`;
    tabs.appendChild(b);
  });
  updateReportAvailability();
}
function renderGuidesPanel(){
  guidesPanel.innerHTML='';
  const GUIDE_DEFS={
    toeoff:[ {key:'g45', label:'Guía 45° extensión', use:'Ubica el punto en el centro de la cadera y comprueba si la extensión de cadera supera los 45°.'} ],
    mvp:[ {key:'heel', label:'Guía talón', use:'Ubica el punto en el talón y comprueba si la pantorrilla está por encima.'} ],
    lateswing:[ {key:'vh', label:'Guía rodilla', use:'Ubica el cruce en la zona glútea y comprueba si la rodilla queda por detrás y si se observa anteversión pélvica.'} ],
   touchdown:[
  {key:'thighs', label:'Guía muslos/tronco', use:'Ubica el punto en el trocánter y luego en la proyección de ambos muslos. Comprueba que el tronco no exceda los 15° de flexión y que el ángulo entre muslos no sea superior a 20°.'},
  {key:'cdg', label:'Guía distancia CdG', use:'Ubica el punto en el talón y compara la medida del pie con la distancia a la vertical.'},
  {key:'tibia', label:'Guía tibia', use:'Ubicá el punto en el centro de la articulación del tobillo y comprobá que la rodilla no esté por detrás.'}
 ],
    midstance:[ {key:'knee', label:'Guía rodilla', use:'Ubicá la línea vertical (puntos en extremos) con el punto superior en la rodilla y verificá que no esté por delante de la punta del pie.'} ]
  }[state.curMoment]||[];
  GUIDE_DEFS.forEach(def=>{
    const row=document.createElement('div'); row.className='q';
    const lab=document.createElement('label'); lab.textContent=def.label;
    const help=document.createElement('span'); help.className='help'; help.textContent='?';
    help.addEventListener('click', (e)=>toggleTip(e.currentTarget, def.use));
    help.addEventListener('touchstart', (e)=>{ e.preventDefault(); toggleTip(e.currentTarget, def.use); }, {passive:false});
    const sw=document.createElement('label'); sw.className='switch';
    const g = ensureGuideState(state.curMoment, def.key);
    const input=document.createElement('input'); input.type='checkbox'; input.checked=!!g.on;
    input.onchange=()=>{ g.on=input.checked; draw(); };
    const slid=document.createElement('span'); slid.className='slider';
    sw.appendChild(input); sw.appendChild(slid);
    lab.appendChild(help);
    row.appendChild(lab); row.appendChild(sw);
    guidesPanel.appendChild(row);
  });
}
function renderQuestions(){
  const m=state.moments[state.curMoment];
  questions.innerHTML='';
  (QUESTIONS[state.curMoment]||[]).forEach((q,i)=>{
    const row=document.createElement('div'); row.className='q';
    const lab=document.createElement('label'); lab.textContent=q;
    const sw=document.createElement('label'); sw.className='switch';
    const input=document.createElement('input'); input.type='checkbox'; input.checked=!!m.checks[i];
    input.onchange=()=>{ m.checks[i]=input.checked; refreshScores(); draw(); };
    const slid=document.createElement('span'); slid.className='slider';
    sw.appendChild(input); sw.appendChild(slid);
    row.appendChild(lab); row.appendChild(sw);
    questions.appendChild(row);
  });
}
function refreshScores(){
  const cur = state.moments[state.curMoment].checks.filter(Boolean).length;
  const total = Object.values(state.moments).reduce((acc,mm)=> acc + mm.checks.filter(Boolean).length, 0);
  momentScoreEl.textContent = cur; totalScoreEl.textContent = total; gradeEl.textContent = GRADE(total);
}

/* ===== Video / Dibujo ===== */
function sizeCanvasToWrap(){ const r=wrap.getBoundingClientRect(); cvs.width=r.width; cvs.height=r.height; mag.width=r.width; mag.height=r.height; }
function draw(){ if(!vid.videoWidth) return; sizeCanvasToWrap(); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.drawImage(vid,0,0,cvs.width,cvs.height); drawGuides(); drawMagnifier(); }
function stepFrames(n){ const fps=Number(state.fps)||240; vid.pause(); const dt=n/fps; const t=Math.max(0,Math.min(vid.duration||0,(vid.currentTime||0)+dt)); vid.currentTime=t; }
function updateTimeUI(){
  const t=vid.currentTime||0, d=vid.duration||0;
  ctime.textContent=t.toFixed(3);
  const fps=Number(state.fps)||240; fnum.textContent=Math.round(t*fps);
  const m=state.moments[state.curMoment]; m.t=t; m.frame=Math.round(t*fps);
  if(d>0){
    const pct=(t/d)*100; playBar.style.width=pct+'%'; thumb.style.left=pct+'%';
    durT.textContent=formatTime(d); curT.textContent=formatTime(t);
    try{ let end=0; if(vid.buffered && vid.buffered.length){ end=vid.buffered.end(vid.buffered.length-1); } bufBar.style.width=(Math.min(end,d)/d)*100+'%'; }catch(e){}
  }
}
function formatTime(s){ s=Math.max(0,Math.floor(s||0)); const m=Math.floor(s/60); const ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }
vid.addEventListener('timeupdate',()=>{ updateTimeUI(); draw(); });
vid.addEventListener('seeked',()=>{ updateTimeUI(); draw(); });
vid.addEventListener('loadedmetadata',()=>{ updateTimeUI(); });
vid.addEventListener('progress',()=>{ updateTimeUI(); });
window.addEventListener('resize', draw);

/* ===== Scrubber ===== */
let scrubbing=false;
function posToTime(clientX){ const r=scrub.getBoundingClientRect(); const x=Math.max(0,Math.min(clientX - r.left, r.width)); const pct=x/r.width; return (vid.duration||0)*pct; }
function beginScrub(clientX){ scrubbing=true; vid.pause(); vid.currentTime=posToTime(clientX); updateTimeUI(); draw(); }
function moveScrub(clientX){ if(!scrubbing) return; vid.currentTime=posToTime(clientX); updateTimeUI(); draw(); }
function endScrub(){ if(!scrubbing) return; scrubbing=false; }
scrub.addEventListener('mousedown',(e)=>{ beginScrub(e.clientX); e.preventDefault(); });
window.addEventListener('mousemove',(e)=>{ moveScrub(e.clientX); });
window.addEventListener('mouseup',()=>{ endScrub(); });
scrub.addEventListener('touchstart',(e)=>{ if(e.touches.length){ beginScrub(e.touches[0].clientX); } e.preventDefault(); }, {passive:false});
window.addEventListener('touchmove',(e)=>{ if(scrubbing && e.touches.length){ moveScrub(e.touches[0].clientX); } }, {passive:false});
window.addEventListener('touchend',()=>{ endScrub(); });

/* ===== Overlay + Lupa ===== */
let dragging=null, dragKey=null; let placingActive=false;
const MAG_RADIUS=70, MAG_SCALE=2.5, MAG_OFFSET={x:90,y:-90};
let magVisible=false, magSrc={x:0,y:0}, magPos={x:0,y:0};
function toCanvasCoords(ev){ const r=cvs.getBoundingClientRect(); const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-r.left; const y=(ev.touches?ev.touches[0].clientY:ev.clientY)-r.top; return {x,y}; }
function hit(pt,x,y){ return pt && Math.hypot(pt.x-x,pt.y-y)<16; }
function cm(){ return state.moments[state.curMoment]; }
function activeGuides(){ const g=cm().guides; return Object.entries(g).filter(([k,v])=>v.on); }
function showMag(cx,cy,px,py){ magVisible=true; mag.style.display='block'; magSrc.x=cx; magSrc.y=cy; magPos.x=Math.max(MAG_RADIUS, Math.min(cvs.width-MAG_RADIUS, px+MAG_OFFSET.x)); magPos.y=Math.max(MAG_RADIUS, Math.min(cvs.height-MAG_RADIUS, py+MAG_OFFSET.y)); drawMagnifier(); }
function moveMag(cx,cy,px,py){ if(!magVisible) return; magSrc.x=cx; magSrc.y=cy; magPos.x=Math.max(MAG_RADIUS, Math.min(cvs.width-MAG_RADIUS, px+MAG_OFFSET.x)); magPos.y=Math.max(MAG_RADIUS, Math.min(cvs.height-MAG_RADIUS, py+MAG_OFFSET.y)); drawMagnifier(); }
function hideMag(){ magVisible=false; mag.style.display='none'; }
function drawMagnifier(){
  const mw=cvs.width, mh=cvs.height; mag.width=mw; mag.height=mh; mctx.clearRect(0,0,mw,mh); if(!magVisible) return;
  const sx = magSrc.x - (MAG_RADIUS/MAG_SCALE), sy = magSrc.y - (MAG_RADIUS/MAG_SCALE);
  const sw = (MAG_RADIUS*2)/MAG_SCALE, sh = (MAG_RADIUS*2)/MAG_SCALE;
  mctx.save(); mctx.beginPath(); mctx.arc(magPos.x, magPos.y, MAG_RADIUS, 0, Math.PI*2); mctx.closePath(); mctx.clip();
  mctx.fillStyle='rgba(0,0,0,1)'; mctx.fillRect(magPos.x-MAG_RADIUS, magPos.y-MAG_RADIUS, MAG_RADIUS*2, MAG_RADIUS*2);
  mctx.imageSmoothingEnabled=true; mctx.drawImage(cvs, sx, sy, sw, sh, magPos.x-MAG_RADIUS, magPos.y-MAG_RADIUS, MAG_RADIUS*2, MAG_RADIUS*2);
  mctx.strokeStyle='rgba(255,255,255,.9)'; mctx.lineWidth=1.5; mctx.beginPath();
  mctx.moveTo(magPos.x-MAG_RADIUS, magPos.y); mctx.lineTo(magPos.x+MAG_RADIUS, magPos.y);
  mctx.moveTo(magPos.x, magPos.y-MAG_RADIUS); mctx.lineTo(magPos.x, magPos.y+MAG_RADIUS); mctx.stroke();
  mctx.strokeStyle='rgba(255,255,255,.8)'; mctx.lineWidth=2; mctx.beginPath(); mctx.arc(magPos.x, magPos.y, MAG_RADIUS, 0, Math.PI*2); mctx.stroke(); mctx.restore();
}
function startDrag(ev){
  placingActive=true; const {x,y}=toCanvasCoords(ev); showMag(x,y,x,y);
  const list = activeGuides();
 for (const [key, g] of list) {
  const d = g.data;

  if (key === 'thighs') {
    if (hit(d.v, x, y)) { dragging = 'v'; dragKey = key; return ev.preventDefault(); }
    if (hit(d.a, x, y)) { dragging = 'a'; dragKey = key; return ev.preventDefault(); }
    if (hit(d.b, x, y)) { dragging = 'b'; dragKey = key; return ev.preventDefault(); }

  } else if (key === 'cdg') {
    if (hit(d.a, x, y)) { dragging = 'a'; dragKey = key; return ev.preventDefault(); }
    if (hit(d.b, x, y)) { dragging = 'b'; dragKey = key; return ev.preventDefault(); }

  } else if (key === 'heel') {
    if (hit(d.p, x, y)) { dragging = 'p'; dragKey = key; return ev.preventDefault(); }

  } else if (['vh', 't15', 'g45', 'knee', 'tibia'].includes(key)) {
    if (hit(d.anchor, x, y)) { dragging = 'anchor'; dragKey = key; return ev.preventDefault(); }
  }
}

 for (const [key, g] of list) {
  const d = g.data;

  if (key === 'thighs') {
    if (!d.v) { d.v = { x, y }; dragging = 'v'; dragKey = key; break; }
    else if (!d.a) { d.a = { x, y }; dragging = 'a'; dragKey = key; break; }
    else if (!d.b) { d.b = { x, y }; dragging = 'b'; dragKey = key; break; }

  } else if (key === 'cdg') {
    // Primer toque: arrastrar 'a'. Al soltar se genera 'b'.
    if (!d.a) {
      d.a = { x, y };
      dragging = 'a';
      dragKey = key;
      break;
    } else if (!d.b) {
      d.b = { x, y: d.a.y }; // fallback manual, normalmente se crea en endDrag
      dragging = 'b';
      dragKey = key;
      break;
    }

  } else if (key === 'heel') {
    if (!d.p) { d.p = { x, y }; dragging = 'p'; dragKey = key; break; }

  } else if (['vh', 't15', 'g45', 'knee', 'tibia'].includes(key)) {
    if (!d.anchor) { d.anchor = { x, y }; dragging = 'anchor'; dragKey = key; break; }
  }
}

  draw(); ev.preventDefault();
}
function moveDrag(ev){
  if(!placingActive) return; const {x,y}=toCanvasCoords(ev); moveMag(x,y,x,y);
 if (!dragging) return;
const g = cm().guides[dragKey]; if (!g) return; const d = g.data;

// Comportamiento general
if (dragKey !== 'cdg') {
  if (dragging === 'v') d.v = { x, y };
  if (dragging === 'a') d.a = { x, y };
  if (dragging === 'b') d.b = { x, y };
  if (dragging === 'p') d.p = { x, y };
  if (dragging === 'anchor') d.anchor = { x, y };
} else {
  // CDG: 'b' SIEMPRE comparte la misma y de 'a'
  if (dragging === 'a') {
    d.a = { x, y };
    if (d.b) d.b = { x: d.b.x, y: y }; // si ya existe b, acompaña la y de a
  } else if (dragging === 'b') {
    const lockedY = d.a ? d.a.y : y;
    d.b = { x, y: lockedY };
  }
}


  draw(); ev.preventDefault();
}
function endDrag(){
  if(!placingActive) return;

  const prevDragKey = dragKey;
  const prevDragging = dragging;
  const g = prevDragKey ? cm().guides[prevDragKey] : null;

  // Caso especial: CdG → soltar 'a' crea 'b' y seguimos arrastrando 'b'
  if (prevDragKey === 'cdg' && prevDragging === 'a' && g && g.data && g.data.a && !g.data.b) {
    const a = g.data.a;
    const offset = Math.min(60, cvs.width * 0.08); // desplazamiento inicial visible
    g.data.b = { x: a.x + offset, y: a.y };

    // Seguimos en modo "placing" arrastrando B con la lupa activa
    dragging = 'b';
    showMag(g.data.b.x, g.data.b.y, g.data.b.x, g.data.b.y);
    draw();
    return; // NO salimos de placing
  }

  // Resto de casos: terminar normalmente
  placingActive = false;
  dragging = null;
  dragKey = null;
  hideMag();
  draw();
}


cvs.addEventListener('mousedown', startDrag);
cvs.addEventListener('mousemove', moveDrag);
cvs.addEventListener('mouseup', endDrag);
cvs.addEventListener('mouseleave', endDrag);
cvs.addEventListener('touchstart', startDrag,{passive:false});
cvs.addEventListener('touchmove', moveDrag,{passive:false});
cvs.addEventListener('touchend', endDrag);

/* ===== Dibujo de guías ===== */
function line(x1,y1,x2,y2,dash=[],color='white',width=2){ ctx.save(); ctx.setLineDash(dash); ctx.lineWidth=width; ctx.strokeStyle=color; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); ctx.restore(); }
function dot(x,y){ ctx.save(); const rr=(placingActive?10:4); ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill(); ctx.restore(); }
function drawVerticalPlusAngleFromVertical(x,y,deg,invert=false){
  line(x,0,x,cvs.height,[], 'rgba(255,255,255,.85)');
  const base=90-deg, theta=(invert?-1:1)*(base*Math.PI/180), len=Math.max(cvs.width,cvs.height);
  const dx=Math.cos(theta)*len, dy=-Math.sin(theta)*len;
  line(x-dx, y+dy, x+dx, y-dy, [6,4], 'rgba(255,255,255,.85)'); dot(x,y);
}
function drawVHAt(x,y){ line(x,0,x,cvs.height,[], 'rgba(255,255,255,.85)'); line(0,y,cvs.width,y,[], 'rgba(255,255,255,.85)'); dot(x,y); }
function angleBetween(p0,p1,p2){
  const v1={x:p0.x-p1.x,y:p0.y-p1.y}, v2={x:p2.x-p1.x,y:p2.y-p1.y};
  const d1=Math.hypot(v1.x,v1.y)||1, d2=Math.hypot(v2.x,v2.y)||1;
  const cos=(v1.x*v2.x+v1.y*v2.y)/(d1*d2);
  return Math.acos(Math.min(1,Math.max(-1,cos)))*180/Math.PI;
}
function drawGuides(){
  const list = activeGuides();
  for(const [key,g] of list){
    const d=g.data;
    if (key === 'g45' && d.anchor) {
  const x = d.anchor.x, y = d.anchor.y;

  // Vertical completa
  line(x, 0, x, cvs.height, [], 'rgba(255,255,255,.85)', 2);

  // Diagonal a 45° SOLO hacia abajo desde el punto (respeta Invertir)
  const deg = 45;
  const phi = (state.invert ? -deg : deg) * Math.PI / 180; // respecto de la vertical
  const L = Math.max(cvs.width, cvs.height) * 1.5;
  const x2 = x + Math.sin(phi) * L;
  const y2 = y + Math.cos(phi) * L; // hacia abajo

  line(x, y, x2, y2, [6, 4], 'rgba(255,255,255,.85)', 2);
  dot(x, y);
}

    if(key==='heel' && d.p){ line(0,d.p.y,cvs.width,d.p.y,[], 'rgba(255,255,255,.85)',2); dot(d.p.x,d.p.y); }
    if(key==='vh' && d.anchor){ drawVHAt(d.anchor.x, d.anchor.y); }
   if(key==='t15' && d.anchor){ drawVerticalPlusAngleFromVertical(d.anchor.x, d.anchor.y, 15, state.invert); }

if (key === 'thighs') {
  const { v, a, b } = d;

  // Puntos existentes
  if (v) dot(v.x, v.y);
  if (a) dot(a.x, a.y);
  if (b) dot(b.x, b.y);

  // === Referencia SIEMPRE visible: vertical + línea a 15° SOLO hacia arriba ===
  if (v) {
    // 1) Vertical completa por el vértice
    line(v.x, 0, v.x, cvs.height, [], 'rgba(255,255,255,.85)', 2);

    // 2) Línea a 15° respecto de la vertical, solo hacia ARRIBA desde el punto
    //    (hacia la derecha si !invert, hacia la izquierda si invert)
    const deg = 15;
    const phi = (state.invert ? -deg : deg) * Math.PI / 180; // ángulo desde la vertical
    const L = Math.max(cvs.width, cvs.height);               // largo suficiente para salir de pantalla hacia arriba
    const x2 = v.x + Math.sin(phi) * L;
    const y2 = v.y - Math.cos(phi) * L; // hacia arriba

    line(v.x, v.y, x2, y2, [6,4], 'rgba(255,255,255,.85)', 2);
  }

  // Lados del ángulo
  if (v && a) { line(v.x, v.y, a.x, a.y, [], '#fff', 2); }
  if (v && b) { line(v.x, v.y, b.x, b.y, [], '#fff', 2); }

  // Cálculo y rótulo del ángulo
  if (v && a && b) {
    const ang = angleBetween(a, v, b);
    ctx.save();
    ctx.fillStyle = ang > 20 ? 'rgba(231,76,60,.9)' : 'rgba(25,179,106,.9)';
    ctx.font = 'bold 14px system-ui';
    ctx.fillText(`${ang.toFixed(1)}°`, v.x + 8, v.y - 8);
    ctx.restore();

    if (ang > 20) {
      ctx.save();
      ctx.strokeStyle = 'rgba(231,76,60,1)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(v.x, v.y, 24, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }
}


if (key === 'cdg') {
  const { a, b } = d;

  // Pintar puntos si existen
  if (a) dot(a.x, a.y);
  if (b) dot(b.x, b.y);

  // Intentar usar la vertical de "Guía muslos/tronco" (thighs)
  const thighs = cm().guides['thighs'];
  const v = thighs && thighs.data && thighs.data.v ? thighs.data.v : null;

  // 1) Medición automática: desde 'a' a la vertical (si hay vértice en 'thighs')
  if (a && v) {
    const y = a.y, x1 = a.x, x2 = v.x;
    const xMin = Math.min(x1, x2), xMax = Math.max(x1, x2);

    // Línea punteada a la vertical
    line(xMin, y, xMax, y, [6, 4], 'rgba(255,255,255,.85)', 2);

    // Rótulo Δx a la vertical
    const dx = Math.abs(Math.round(x2 - x1));
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText(`Δx a vertical: ${dx}px`, xMin + 5, y - 10);
    ctx.restore();

    // Dibujar la propia vertical de referencia (suave)
    line(v.x, 0, v.x, cvs.height, [], 'rgba(255,255,255,.25)', 1);
  }

  // 2) Medición de "largo de pie": entre 'a' y 'b' (misma y)
  if (a && b) {
    const y = a.y;
    const xMin = Math.min(a.x, b.x), xMax = Math.max(a.x, b.x);

    // Línea sólida para "pie"
    line(xMin, y, xMax, y, [], 'rgba(255,255,255,1)', 2);

    // Rótulo pie
    const footLen = Math.abs(Math.round(b.x - a.x));
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText(`pie: ${footLen}px`, xMin + 5, y + 16);
    ctx.restore();
  }
}



   if (key === 'knee' && d.anchor) {
  // Vertical completa en x del punto + punto visible
  const x = d.anchor.x, y = d.anchor.y;
  line(x, 0, x, cvs.height, [], 'rgba(255,255,255,.95)', 3);
  dot(x, y);
}

   if (key === 'tibia' && d.anchor) {
  // Vertical completa en x del punto + punto visible
  const x = d.anchor.x, y = d.anchor.y;
  line(x, 0, x, cvs.height, [], 'rgba(255,255,255,.95)', 3);
  dot(x, y);
}

  }
  ctx.save(); ctx.fillStyle='rgba(255,255,255,.6)'; ctx.font='12px system-ui'; ctx.fillText('Activá guías y tocá para ubicarlas. Arrastrá para ajustar.',10,cvs.height-10); ctx.restore();
}

/* ===== Controles ===== */
document.getElementById('play').onclick=async()=>{ try{ if(vid.paused){ await vid.play(); } else { vid.pause(); } }catch(e){} };
document.getElementById('back1').onclick=()=>stepFrames(-1);
document.getElementById('fwd1').onclick=()=>stepFrames(1);
document.getElementById('back10').onclick=()=>stepFrames(-10);
document.getElementById('fwd10').onclick=()=>stepFrames(10);
invertBtn.onclick=()=>{ state.invert=!state.invert; draw(); };
/* ===== Helpers de recorte ===== */
function getCropCenterForMoment(mKey){
  const g = (state.moments[mKey]?.guides) || {};
  const centerDefault = { x: cvs.width/2, y: cvs.height/2 };

  if(mKey==='toeoff'   && g.g45   && g.g45.data?.anchor) return g.g45.data.anchor;     // 45° → anchor
  if(mKey==='mvp'      && g.heel  && g.heel.data?.p)     return g.heel.data.p;         // talón → p
  if(mKey==='touchdown'&& g.thighs&& g.thighs.data?.v)   return g.thighs.data.v;       // muslos/tronco → vértice v
  if(mKey==='midstance'&& g.knee  && g.knee.data?.anchor)return g.knee.data.anchor;    // rodilla → anchor
  if(mKey==='lateswing'&& g.vh    && g.vh.data?.anchor)  return g.vh.data.anchor;      // (fallback)
  return centerDefault;
}

function captureCroppedRect(center){
  // Alto = alto del canvas (frame actual)
  let H = cvs.height;
  // Ancho = 3/4 del alto
  let W = Math.round(H * 0.75);

  // Si el ancho supera el canvas, escalamos ambos para que quepa
  if (W > cvs.width) {
    const f = cvs.width / W;
    W = Math.round(W * f);
    H = Math.round(H * f);
  }

  // Top-left clamp para que el rectángulo quede dentro del canvas
  const x = Math.max(0, Math.min(Math.round(center.x - W/2), cvs.width  - W));
  const y = Math.max(0, Math.min(Math.round(center.y - H/2), cvs.height - H));

  // Recorte desde el canvas (que ya tiene video + guías dibujadas)
  const off = document.createElement('canvas');
  off.width = W; off.height = H;
  const octx = off.getContext('2d');
  octx.drawImage(cvs, x, y, W, H, 0, 0, W, H);
  return off.toDataURL('image/png');
}

  document.getElementById('snap').onclick=()=>{
  const dataURL=cvs.toDataURL('image/png');
  const mKey=state.curMoment, m=state.moments[mKey];
  m.snapshots.push({dataURL,when:new Date().toISOString(),frame:m.frame,t:m.t});
  m.captured=true; renderTabs();
  const gobj = m.guides; Object.keys(gobj).forEach(k => { if(gobj[k] && gobj[k].on) gobj[k].on = false; });
  placingActive=false; dragging=null; dragKey=null; hideMag(); draw();
  const idx = MOMENTS.findIndex(mm=>mm.key===mKey);
  if(idx < MOMENTS.length - 1){ setMoment(MOMENTS[idx+1].key); } else { alert('Ya podés generar el reporte.'); }
};
notesEl.oninput=()=>{ state.moments[state.curMoment].notes=notesEl.value; };
fpsInput.onchange=()=>{ state.fps=Number(fpsInput.value)||240; updateTimeUI(); };

/* ===== Reporte ===== */
function computeNeeds(){
  const answers=[];
  function pushMoment(key){ const arr=state.moments[key].checks; for(let i=0;i<arr.length;i++){ answers.push(arr[i]); } }
  pushMoment('toeoff'); pushMoment('mvp'); pushMoment('lateswing'); pushMoment('touchdown'); pushMoment('midstance');
  const groups={
    'Control lumbopélvico':[2,4,7],
    'Back-side mechanics':[1,3,5,8],
    'Overstriding':[6,9,10,11,12]
  };
  const tally={};
  for(const [name, idxs] of Object.entries(groups)){
    tally[name]=idxs.reduce((s,i)=> s + (answers[i-1]?1:0), 0);
  }
  const max = Math.max(...Object.values(tally));
  const winners = Object.keys(tally).filter(k=>tally[k]===max && max>0);
  return {tally, winners, max};
}

// === REEMPLAZA TODO TU printReport.onclick POR ESTO ===
document.getElementById('printReport').onclick = () => {
  const container = document.getElementById('reportContent');
  container.innerHTML = '';

  // ——— datos base
  const total = Object.values(state.moments)
    .reduce((acc, mm) => acc + mm.checks.filter(Boolean).length, 0);
  const needs = computeNeeds(); // {tally:{...}, winners:[...], max:number}

  // ====== criterios en texto ======
  const CRITERIA_TEXT = {
    1:'Extensión de cadera excesiva',
    2:'Rotación excesiva de tronco',
    3:'Talón trasero por encima de la pantorrilla',
    4:'Anteversión pélvica / extensión lumbar en swing',
    5:'Rodilla por detrás de los glúteos',
    6:'Inclinación del tronco hacia delante',
    7:'Anteversión pélvica / extensión lumbar en apoyo',
    8:'Ángulo entre muslos > 20°',
    9:'Pie adelantado respecto al CdG (overstriding)',
    10:'Tibia inclinada en contacto',
    11:'Primer apoyo marcado (talón/punta)',
    12:'Rodilla por delante de la punta del pie'
  };

  // grupos e índices
  const GROUPS = {
    'Control lumbopélvico':[2,4,7],
    'Back-side mechanics':[1,3,5,8],
    'Overstriding':[6,9,10,11,12]
  };

  // respuestas aplanadas (true/false por criterio 1..12)
  const answers = (() => {
    const a=[]; const push=(k)=>{ for(const v of state.moments[k].checks) a.push(v); };
    push('toeoff'); push('mvp'); push('lateswing'); push('touchdown'); push('midstance');
    return a;
  })();

  // criterios activos (texto) por grupo
  function activeCriteriaFor(groupName){
    const idxs = GROUPS[groupName]||[]; const out=[];
    for(const idx of idxs){ if(answers[idx-1]) out.push(CRITERIA_TEXT[idx]); }
    return out;
  }

  // ====== Donut (SVG) ======
  function donutSVG(tally){
    const DATA = [
      {name:'Control lumbopélvico', value: tally['Control lumbopélvico']||0, color:'#2563eb'},
      {name:'Back-side mechanics',  value: tally['Back-side mechanics'] ||0, color:'#f59e0b'},
      {name:'Overstriding',         value: tally['Overstriding']        ||0, color:'#ef4444'}
    ];
    const sum = DATA.reduce((s,d)=>s+d.value,0) || 1;
    const R=54, IR=32, CX=70, CY=70; let a0=-Math.PI/2;
    const arc=(cx,cy,r,a0,a1)=>`M ${cx+r*Math.cos(a0)} ${cy+r*Math.sin(a0)} A ${r} ${r} 0 ${((a1-a0)>Math.PI)?1:0} 1 ${cx+r*Math.cos(a1)} ${cy+r*Math.sin(a1)}`;
    let paths='';
    DATA.forEach(d=>{
      const a1=a0+(d.value/sum)*Math.PI*2;
      const outer=arc(CX,CY,R,a0,a1), inner=arc(CX,CY,IR,a1,a0);
      paths += `<path d="${outer} L ${CX+IR*Math.cos(a1)} ${CY+IR*Math.sin(a1)} ${inner} Z" fill="${d.color}" opacity="${d.value?1:0.18}"></path>`;
      a0=a1;
    });
    return `
      <svg width="140" height="140" viewBox="0 0 140 140" aria-hidden="true">
        <g>
          ${paths}
          <circle cx="${CX}" cy="${CY}" r="${IR}" fill="#fff"></circle>
          <text x="${CX}" y="${CY-2}" text-anchor="middle" font-family="system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif" font-size="20" font-weight="800" fill="#0b1b2b">${needs.max}</text>
          <text x="${CX}" y="${CY+14}" text-anchor="middle" font-family="system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif" font-size="10" fill="#6b7280">máx. checks</text>
        </g>
      </svg>`;
  }

  // ====== Círculos PUNTAJE ======
  const activeBucket = (() => {
    if (total <= 1) return 'ex';
    if (total === 2) return 'good';
    if (total <= 5) return 'avg';
    if (total === 6) return 'poor';
    if (total <= 11) return 'vpoor';
    return 'xpoor';
  })();
  const buckets = [
    {key:'ex',range:'0–1',label:'Excelente',color:'#E0F255'},
    {key:'good',range:'2',label:'Bueno',color:'#F0F77A'},
    {key:'avg',range:'3–5',label:'Promedio',color:'#F3F8A8'},
    {key:'poor',range:'6',label:'Pobre',color:'#F3B7A8'},
    {key:'vpoor',range:'7–11',label:'Muy pobre',color:'#DE6B58'},
    {key:'xpoor',range:'12',label:'Extremadamente pobre',color:'#D64A3E'}
  ];
  const OFF_BG='#f6f7fb', OFF_BDR='#e5e7eb', OFF_TXT='#9aa3ad';
  function circleHTML(item){
    const on=item.key===activeBucket;
    const bg=on?item.color:OFF_BG, bdr=on?'transparent':OFF_BDR;
    const txt=on?( ['vpoor','xpoor'].includes(item.key)?'#fff':'#0b1b2b' ):OFF_TXT;
    const weight=on?800:700, shadow=on?'inset 0 6px 14px rgba(0,0,0,.08)':'none', opacity=on?1:.9;
    return `
      <div class="gc-item">
        <div class="gc-dot" style="background:${bg};border:1px solid ${bdr};color:${txt};box-shadow:${shadow};opacity:${opacity};font-weight:${weight};">${item.range}</div>
        <div class="gc-cap">${item.label}</div>
      </div>`;
  }

  // ====== CSS portada ======
  const coverCSS = `
    <style>
      /* Bloque DATOS (nuevo) */
      #report .infoBox{border:1px solid #e5e7eb;background:#fafafa;border-radius:10px;padding:10px 12px;margin:10px 0 8px 0;}
      #report .infoBox .title{font-weight:800;letter-spacing:.8px;color:#0b1b2b;font-size:14px;margin:0 0 6px 0;}
      #report .infoBox .row{display:flex;gap:16px;flex-wrap:wrap;}
      #report .infoBox .pill{background:#f3f4f6;border:1px solid #e5e7eb;color:#111827;padding:6px 10px;border-radius:999px;font-weight:600;font-size:12px;}

      /* Bloque PUNTAJE */
      #report .scoreBox{border:1px solid #e5e7eb;background:#fafafa;border-radius:10px;padding:10px 12px;margin:10px 0 8px 0;}
      #report .scoreBox .title{font-weight:800;letter-spacing:.8px;color:#0b1b2b;font-size:14px;margin:0 0 6px 0;}
      #report .scoreBox .total{font-size:12px;color:#111827;margin:0 0 8px 0;}
      #report .grade-circles{display:flex;flex-wrap:nowrap;justify-content:space-between;align-items:flex-start;gap:8px;width:100%;}
      #report .grade-circles .gc-item{flex:1 1 0;min-width:0;display:flex;flex-direction:column;align-items:center;gap:4px;}
      #report .grade-circles .gc-dot{width:56px;height:56px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:16px;letter-spacing:.2px;}
      #report .grade-circles .gc-cap{font-size:10px;color:#374151;text-align:center;line-height:1.1;max-width:80px;}

      /* Bloque ÁREA DE MAYOR NECESIDAD */
      #report .needBox{border:1px solid #e5e7eb;background:#fafafa;border-radius:10px;padding:10px 12px;margin-top:8px;}
      #report .needBox .title{font-weight:800;letter-spacing:.8px;color:#0b1b2b;font-size:14px;margin:0 0 8px 0;}
      #report .needBox .row{display:flex;align-items:flex-start;gap:14px;flex-wrap:wrap;}
      #report .needBox .col{flex:1 1 240px;min-width:220px;}
      #report .needBox .groupTitle{display:flex;align-items:center;gap:8px;font-size:12px;font-weight:700;color:#0b1b2b;margin:8px 0 4px 0;}
      #report .needBox .dot{width:10px;height:10px;border-radius:50%;display:inline-block;}
      #report .needBox ul{margin:4px 0 0 16px;font-size:11px;}
      #report .needBox .empty{color:#6b7280;font-size:11px;}
    </style>
  `;

  // ====== Portada ======
  const page1 = document.createElement('div');
  page1.className = 'page';

  // DATOS (nombre + fecha)
  const athleteName = (document.getElementById('athleteName')?.value || '').trim() || '—';
  const now = new Date();
  // Formato dd/mm/yyyy hh:mm (24h)
  const fecha = `${String(now.getDate()).padStart(2,'0')}/${String(now.getMonth()+1).padStart(2,'0')}/${now.getFullYear()} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;

  const coverHTML = `
    ${coverCSS}
    <div style="display:flex;align-items:center;gap:10px">
      <svg width="44" height="44" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#0f2a44"/><stop offset="1" stop-color="#2b5178"/></linearGradient></defs>
        <circle cx="32" cy="32" r="30" fill="url(#g)"/>
        <path d="M16 38 L28 26 L36 34 L48 22" stroke="#ff7a00" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      <div>
        <h1 style="margin:0;font-size:20px">S-MAS Project • Sprint Mechanics Assessment</h1>
        <div style="font-size:12px;color:#444"><strong>Reporte automatizado desarrollado por Santiago Grosso</strong></div>
        </div>
    </div>

    <!-- Bloque DATOS -->
    <div class="infoBox">
      <div class="title">DATOS</div>
      <div class="row">
        <span class="pill">Nombre: <strong>${athleteName}</strong></span>
        <span class="pill">Fecha: <strong>${fecha}</strong></span>
      </div>
    </div>

    <!-- Bloque PUNTAJE -->
    <div class="scoreBox">
      <div class="title">PUNTAJE</div>
      <div class="total">Puntaje total: <strong>${total}</strong></div>
      <div class="grade-circles">
        ${buckets.map(circleHTML).join('')}
      </div>
    </div>

    <!-- Bloque ÁREA DE MAYOR NECESIDAD -->
    <div class="needBox">
      <div class="title">ÁREA DE MAYOR NECESIDAD</div>
      <div class="row">
        <div class="col" style="flex:0 0 160px;display:flex;align-items:center;justify-content:center;">
          ${donutSVG(needs.tally)}
        </div>
        <div class="col">
          <!-- Cada título de grupo AHORA lleva el puntito del color correspondiente -->
          <div>
            <div class="groupTitle"><span class="dot" style="background:#2563eb"></span>Control lumbopélvico</div>
            ${(() => {
              const act = activeCriteriaFor('Control lumbopélvico');
              return act.length ? `<ul>${act.map(t=>`<li>${t}</li>`).join('')}</ul>` : `<div class="empty">Sin ítems activados</div>`;
            })()}
          </div>

          <div>
            <div class="groupTitle"><span class="dot" style="background:#f59e0b"></span>Back-side mechanics</div>
            ${(() => {
              const act = activeCriteriaFor('Back-side mechanics');
              return act.length ? `<ul>${act.map(t=>`<li>${t}</li>`).join('')}</ul>` : `<div class="empty">Sin ítems activados</div>`;
            })()}
          </div>

          <div>
            <div class="groupTitle"><span class="dot" style="background:#ef4444"></span>Overstriding</div>
            ${(() => {
              const act = activeCriteriaFor('Overstriding');
              return act.length ? `<ul>${act.map(t=>`<li>${t}</li>`).join('')}</ul>` : `<div class="empty">Sin ítems activados</div>`;
            })()}
          </div>
        </div>
      </div>
    </div>
  `;

  const page1Inner = document.createElement('div');
  page1Inner.innerHTML = coverHTML;
  page1.appendChild(page1Inner);

  // ——— bloques de momentos (iguales que antes)
  const blocks=[];
  MOMENTS.forEach(m=>{
    const mm=state.moments[m.key];
    const latest=mm.snapshots[mm.snapshots.length-1];
    const checks=(QUESTIONS[m.key]||[]).map((q,i)=>`<li>${mm.checks[i]?'✅':'⬜️'} ${q}</li>`).join('');
    const notes = mm.notes ? `<div class="notes"><strong>Notas:</strong> ${mm.notes.replace(/</g,'&lt;')}</div>` : '';
    const img = latest ? `<img src="${latest.dataURL}" alt="${m.label}" />`
                       : `<div style="color:#666;padding:12px;border:1px dashed #ccc;border-radius:6px;background:#fafafa">Sin captura</div>`;
    const block=document.createElement('div'); block.className='momentBlock';
    block.innerHTML = `
      <h2 style="margin:3mm 0 1mm 0;">${m.label}</h2>
      <div class="row">
        ${img}
        <div class="col"><strong>Checklist</strong><ul>${checks}</ul>${notes}</div>
      </div>`;
    blocks.push(block);
  });

  if(blocks.length) page1.appendChild(blocks[0]);
  container.appendChild(page1);

  // ——— página 2
  const page2=document.createElement('div'); page2.className='page';
  if(blocks[1]) page2.appendChild(blocks[1]);
  if(blocks[2]) page2.appendChild(blocks[2]);
  container.appendChild(page2);

  // ——— página 3
  const page3=document.createElement('div'); page3.className='page';
  if(blocks[3]) page3.appendChild(blocks[3]);
  if(blocks[4]) page3.appendChild(blocks[4]);
  container.appendChild(page3);

  // ——— imprimir
  window.print();
};


// === FIN REEMPLAZO ===




/* ===== Pantalla completa (Zoom) — único bloque ===== */
const fsBtn = document.getElementById('fs');
const viewArea = document.getElementById('viewArea');

function isFullscreen(){
  return !!(document.fullscreenElement || document.webkitFullscreenElement);
}
async function enterFullscreen(el){
  try{
    if(el && el.requestFullscreen){ await el.requestFullscreen(); }
    else if(el && el.webkitRequestFullscreen){ el.webkitRequestFullscreen(); }
  }catch(e){}
}
async function exitFullscreen(){
  try{
    if(document.exitFullscreen){ await document.exitFullscreen(); }
    else if(document.webkitExitFullscreen){ document.webkitExitFullscreen(); }
  }catch(e){}
}
if (fsBtn){
  fsBtn.onclick = async () => {
    if(!isFullscreen()){ await enterFullscreen(viewArea || wrap); }
    else { await exitFullscreen(); }
  };
  function refreshFsLabel(){ fsBtn.textContent = isFullscreen() ? 'Salir zoom' : 'Zoom'; }
  document.addEventListener('fullscreenchange', refreshFsLabel);
  document.addEventListener('webkitfullscreenchange', refreshFsLabel);
  refreshFsLabel();
}

/* ===== Init ===== */
document.getElementById('clearState').onclick=()=>{
  if(confirm('¿Borrar progreso de esta sesión?')){
    state={fps:240,invert:false,curMoment:'toeoff', moments:Object.fromEntries(MOMENTS.map(m=>[m.key,{
      t:0,frame:0,notes:'',checks:(QUESTIONS[m.key]||[]).map(()=>false), snapshots:[], captured:false, guides:{}
    }]))};
    renderTabs(); setMoment('toeoff'); fpsInput.value=state.fps;
  }
};
file.onchange=()=>{
  const f=file.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); vid.src=url; vid.load();
  vid.onloadedmetadata=()=>{ const r=wrap.getBoundingClientRect(); cvs.width=r.width; cvs.height=r.height; vid.currentTime=0.001; updateTimeUI(); };
};
(function init(){ renderTabs(); setMoment(state.curMoment); fpsInput.value=state.fps; updateReportAvailability(); })();
</script>
</body>
</html>
